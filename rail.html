<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ã¤ãªã’ã¦ï¼ãƒˆãƒ­ãƒƒã‚³</title>
    <script src="ranking.js"></script>
    <script type="module" src="firebase-ranking.js"></script>
    <style>

        * {
            touch-action: none;
            user-select: none;
            -webkit-user-select: none; /* Safariç”¨ */
            -webkit-touch-callout: none; /* é•·æŠ¼ã—ãƒ¡ãƒ‹ãƒ¥ãƒ¼ç¦æ­¢ */
        }

        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden; /* ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ¼ã‚’æ¶ˆã™ */
            
            /* â–¼ ã“ã“ãŒæœ€å¼·ã®å›ºå®šè¨­å®š â–¼ */
            position: fixed; /* ç”»é¢ã‚’é‡˜ä»˜ã‘ã«ã™ã‚‹ */
            inset: 0;        /* ä¸Šä¸‹å·¦å³ãƒ”ãƒƒãƒãƒªå¼µã‚Šä»˜ã‘ã‚‹ */
            overscroll-behavior: none; /* ãƒã‚¦ãƒ³ãƒ‰ï¼ˆãƒœãƒ¨ãƒ¨ãƒ³ï¼‰ã‚’ç¦æ­¢ */
            /* â–² ã“ã“ã¾ã§ â–² */

            background-color: #a5d6a7;
            font-family: "UD Digital Kyokasho-tai-R", sans-serif;
            
            /* ã‚¿ãƒƒãƒæ“ä½œã®ç„¡åŠ¹åŒ–ï¼ˆãƒœã‚¿ãƒ³ãªã©ã¯å€‹åˆ¥ã«æœ‰åŠ¹åŒ–ã•ã‚Œã‚‹ï¼‰ */
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
            
            /* ä¸­èº«ã®é…ç½® */
            display: flex;
            justify-content: center;
            align-items: center;
        }
        /* â–²â–²â–² ã“ã“ã¾ã§ â–²â–²â–² */

        #game-container {
            position: relative;
            width: 100%;
            max-width: 500px;
            height: 100%;
            max-height: 900px;
            background-color: #e8f5e9;
            box-shadow: 0 0 20px rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: #c8e6c9;
            display: block;
            z-index: 0;
            /* â–¼â–¼â–¼ ä¿®æ­£ï¼šã‚¿ãƒƒãƒæ“ä½œã«ã‚ˆã‚‹ã‚ºãƒ¼ãƒ ãƒ»ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’ç„¡åŠ¹åŒ– â–¼â–¼â–¼ */
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            /* â–²â–²â–² ã“ã“ã¾ã§ â–²â–²â–² */
        }

        /* ãƒ˜ãƒƒãƒ€ãƒ¼ */
        .header-ui {
            position: absolute;
            top: 0; left: 0;
            width: 100%;
            padding: 10px 0;
            background: rgba(255,255,255,0.9);
            text-align: center;
            font-weight: bold;
            color: #2e7d32;
            font-size: 18px;
            border-bottom: 2px solid #81c784;
            display: flex;
            justify-content: space-around;
            z-index: 10;
            box-sizing: border-box;
            pointer-events: none; /* UIã®ä¸‹ã®ãƒ¬ãƒ¼ãƒ«ã‚‚è§¦ã‚Œã‚‹ã‚ˆã†ã« */
        }

        /* ã‚¹ãƒ”ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ */
        .speed-btn {
            position: absolute;
            bottom: 40px; right: 20px;
            width: 90px; height: 90px;
            background: #2196f3;
            color: white;
            border-radius: 50%;
            border: 4px solid white;
            font-weight: bold;
            font-size: 16px;
            box-shadow: 0 4px rgba(0,0,0,0.3);
            cursor: pointer;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            user-select: none;
            z-index: 50; 
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
        }
        .speed-btn:active { background: #1976d2; transform: scale(0.95); }

        /* ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ */
        .overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            text-align: center;
            color: white;
        }

        .btn {
            background: #ff9800; color: white;
            border: none; padding: 15px 40px;
            font-size: 24px; border-radius: 50px;
            font-weight: bold; cursor: pointer;
            box-shadow: 0 5px #e65100;
            margin-top: 20px;
        }
        .btn:active { transform: scale(0.95); box-shadow: none; }

    </style>
</head>
<body>

<div id="game-container">
    <div class="header-ui">
        <span>ã‚¹ãƒ†ãƒ¼ã‚¸: <span id="level-disp">1</span> / 5</span>
        <div class="status-item">ã‚¿ã‚¤ãƒ : <span id="time-disp">0.0</span>s</div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <button class="speed-btn" id="go-btn" 
        ontouchstart="speedUp(true); event.preventDefault();" 
        ontouchend="speedUp(false); event.preventDefault();" 
        onmousedown="speedUp(true)" 
        onmouseup="speedUp(false)"
        onmouseleave="speedUp(false)">
        <div style="font-size: 24px;">â©</div>
        <div>GO!</div>
    </button>

    <div id="start-screen" class="overlay">
        <div style="font-size:60px;">ğŸšƒ</div>
        <h1 style="margin:10px;">ã¤ãªã’ã¦ï¼<br>ãƒˆãƒ­ãƒƒã‚³</h1>
        <p>ãƒ¬ãƒ¼ãƒ«ã‚’ã‚¿ãƒƒãƒ—ã—ã¦ å›è»¢ï¼<br>ã‚´ãƒ¼ãƒ«ã¾ã§ ç·šè·¯ã‚’ ã¤ãªã’ã‚ˆã†</p>
        <p style="color:#81c784; font-weight:bold;">ãœã‚“ã¶ã§ 5ã‚¹ãƒ†ãƒ¼ã‚¸ï¼</p>
        <button class="btn" onclick="startGame()">ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
        <br>
        <a href="index.html" style="color:#fff; text-decoration:underline;">ğŸ  ã‚‚ã©ã‚‹</a>
    </div>

    <div id="gameover-screen" class="overlay" style="display:none;">
        <h1 style="color:#ff5252;">ã ã£ã›ã‚“ï¼</h1>
        <div style="font-size:80px;">ğŸ’¥</div>
        <p>ã¨ã¡ã‚…ã†ã§ ç·šè·¯ãŒ ãªã‹ã£ãŸã‚ˆ...</p>
        <button class="btn" onclick="retryGame()">ã‚‚ã†ã„ã¡ã©</button>
        <br>
        <a href="index.html" style="color:#fff; text-decoration:underline;">ğŸ  ãƒ›ãƒ¼ãƒ ã¸</a>
    </div>

    <div id="clear-screen" class="overlay" style="display:none;">
        <h1 style="color:#69f0ae;">ã‚´ãƒ¼ãƒ«ï¼</h1>
        <div style="font-size:80px;">ğŸš©</div>
        <p>ã¤ãã®ã‚¹ãƒ†ãƒ¼ã‚¸ã¸ ã„ãã‚ˆï¼</p>
        <button class="btn" onclick="nextLevel()">ã¤ãã¸</button>
    </div>

    <div id="all-clear-screen" class="overlay" style="display:none;">
    <h1 style="color:#ffeb3b; text-shadow:0 0 10px #f57f17;">ã‹ã‚“ãœã‚“<br>ã‚¯ãƒªã‚¢ï¼</h1>
    <div style="font-size:100px;">â±ï¸</div>
    <p style="font-size:20px;">ã•ã„ã”ã¾ã§ ã‚ã‚ŠãŒã¨ã†ï¼<br>ãã¿ã¯ ç·šè·¯ãƒã‚¹ã‚¿ãƒ¼ã ï¼</p>
    
    <div style="font-size:24px; font-weight:bold; margin:20px;">
        ã‚¿ã‚¤ãƒ : <span id="final-score">0.00</span> ç§’
    </div>

    <button class="btn" style="background: #e91e63;" onclick="saveScoreToRanking()">
        ğŸ† ã‚¿ã‚¤ãƒ ã‚’ãã‚ãã™ã‚‹
    </button>
    <button class="btn" onclick="location.reload()">ã•ã„ã—ã‚‡ã‹ã‚‰</button>
    <br>
    <a href="index.html" style="color:#fff; text-decoration:underline;">ğŸ  ãƒ›ãƒ¼ãƒ ã¸</a>
    </div>
</div>

<script>
// â–¼â–¼â–¼ ã€è¿½åŠ ã€‘ç”»é¢ã‚ºãƒ¬ãƒ»ã‚ºãƒ¼ãƒ å®Œå…¨é˜²æ­¢ã‚³ãƒ¼ãƒ‰ â–¼â–¼â–¼
    
    // 1. æŒ‡ã‚’å‹•ã‹ã—ã¦ç”»é¢ãŒã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã™ã‚‹ã®ã‚’é˜²ã
    document.addEventListener('touchmove', function(e) {
        if (e.target.tagName !== 'BUTTON') { // ãƒœã‚¿ãƒ³ä»¥å¤–ã¯ç„¡è¦–
            e.preventDefault();
        }
    }, { passive: false });

    // 2. ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—ã§ã®ã‚ºãƒ¼ãƒ ã‚’é˜²ã
    document.addEventListener('dblclick', function(e) {
        e.preventDefault();
    }, { passive: false });

    // 3. 2æœ¬æŒ‡ã§ã®ãƒ”ãƒ³ãƒã‚ºãƒ¼ãƒ ã‚’é˜²ã
    document.addEventListener('touchstart', function(e) {
        if (e.touches.length > 1) {
            e.preventDefault();
        }
    }, { passive: false });

    // â–²â–²â–² ã“ã“ã¾ã§è¿½åŠ  â–²â–²â–²

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const playerImg = new Image();
    playerImg.src = "player.png"; 

    const COLS = 5;
    const ROWS = 6;
    const MAX_LEVEL = 5; 
    
    let tileSize = 0;
    let offsetX = 0;
    let offsetY = 0;

    let isPlaying = false;
    let level = 1;
    let gameStartTime = 0; 
    let finalTime = 0;

    let grid = []; 
    let train = { x: 0, y: 0, dir: 1, progress: 0, speed: 0.005 }; 
    let isSpeedUp = false;
    
    let countdownVal = 0;
    let countdownTimer = null;

    const TYPES = {
        STRAIGHT: [ { type: 'I_VER', c: [1,0,1,0] }, { type: 'I_HOR', c: [0,1,0,1] } ],
        CURVE: [
            { type: 'C_UR', c: [1,1,0,0] }, 
            { type: 'C_RD', c: [0,1,1,0] }, 
            { type: 'C_DL', c: [0,0,1,1] }, 
            { type: 'C_LU', c: [1,0,0,1] }  
        ]
    };

    function resize() {
        const container = document.getElementById('game-container');
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;

        const padding = 20;
        const availableW = canvas.width - padding * 2;
        const availableH = canvas.height - padding * 2;
        const headerHeight = 50; 
        
        tileSize = Math.min(availableW / COLS, (availableH - headerHeight) / ROWS);
        offsetX = (canvas.width - tileSize * COLS) / 2;
        offsetY = (canvas.height - tileSize * ROWS) / 2 + (headerHeight / 2);
        
        draw();
    }
    window.addEventListener('resize', resize);

    function startGame() {
        document.getElementById('start-screen').style.display = 'none';
        level = 1;
        gameStartTime = Date.now();
        initLevel();
    }

    function retryGame() {
        document.getElementById('gameover-screen').style.display = 'none';
        initLevel(); 
    }

    function nextLevel() {
        if(level >= MAX_LEVEL) {
            document.getElementById('clear-screen').style.display = 'none';
            finalTime = ((Date.now() - gameStartTime) / 1000).toFixed(2); 
            
            // ã‚¯ãƒªã‚¢ç”»é¢ã®è¡¨ç¤ºæ›´æ–°
            document.getElementById('final-score').textContent = finalTime;
            document.getElementById('all-clear-screen').style.display = 'flex';
        } else {
            document.getElementById('clear-screen').style.display = 'none';
            level++;
            initLevel();
        }
    }

    function saveScoreToRanking() {
        if (typeof showSaveDialog === 'function') {
            showSaveDialog('rail', finalTime);
        } else {
            alert('ranking.js ãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“');
        }
    }

    function generatePath() {
        let path = [];
        for(let attempt = 0; attempt < 200; attempt++) {
            path = [{x:0, y:0}];
            let visited = Array(ROWS).fill().map(() => Array(COLS).fill(false));
            visited[0][0] = true;

            let curr = {x:1, y:0};
            path.push(curr);
            visited[0][1] = true;

            if (solveMaze(curr, visited, path)) return path; 
        }
        return [{x:0,y:0}, {x:1,y:0}, {x:2,y:0}, {x:3,y:0}, {x:4,y:0}, 
                {x:4,y:1}, {x:4,y:2}, {x:4,y:3}, {x:4,y:4}, {x:4,y:5}];
    }

    function solveMaze(curr, visited, path) {
        if(curr.x === COLS-1 && curr.y === ROWS-1) return true;
        const dirs = [{dx:0, dy:-1}, {dx:1, dy:0}, {dx:0, dy:1}, {dx:-1, dy:0}].sort(() => Math.random() - 0.5);

        for(let d of dirs) {
            let nx = curr.x + d.dx;
            let ny = curr.y + d.dy;
            if(nx >= 0 && nx < COLS && ny >= 0 && ny < ROWS && !visited[ny][nx]) {
                visited[ny][nx] = true;
                path.push({x:nx, y:ny});
                if(solveMaze({x:nx, y:ny}, visited, path)) return true;
                path.pop();
                visited[ny][nx] = false;
            }
        }
        return false;
    }

    function initLevel() {
        isPlaying = true;
        isSpeedUp = false;
        
        countdownVal = 3;
        if(countdownTimer) clearInterval(countdownTimer);
        countdownTimer = setInterval(() => {
            countdownVal--;
            if(countdownVal < 0) clearInterval(countdownTimer);
        }, 1000); 

        grid = [];
        for(let r=0; r<ROWS; r++) {
            let row = [];
            for(let c=0; c<COLS; c++) row.push({ type: null, fixed: false });
            grid.push(row);
        }

        const path = generatePath();

        for(let i=0; i<path.length; i++) {
            const curr = path[i];
            const prev = i > 0 ? path[i-1] : {x: -1, y: 0};
            const next = i < path.length - 1 ? path[i+1] : {x: COLS, y: ROWS-1}; 

            const fromDir = getDir(curr, prev); 
            const toDir = getDir(curr, next);

            let requiredC = [0,0,0,0];
            requiredC[fromDir] = 1;
            requiredC[toDir] = 1;

            const correctTile = findTileByConnect(requiredC);
            grid[curr.y][curr.x].type = correctTile;
            
            if(i === 0 || i === path.length - 1) {
                grid[curr.y][curr.x].fixed = true;
            } else {
                const isStraight = (correctTile.c[0] === 1 && correctTile.c[2] === 1) || (correctTile.c[1] === 1 && correctTile.c[3] === 1);
                if(isStraight) {
                    grid[curr.y][curr.x].type = TYPES.STRAIGHT[Math.floor(Math.random()*2)];
                } else {
                    grid[curr.y][curr.x].type = TYPES.CURVE[Math.floor(Math.random()*4)];
                }
            }
        }

        for(let r=0; r<ROWS; r++) {
            for(let c=0; c<COLS; c++) {
                if(!grid[r][c].type) {
                    const group = Math.random() > 0.5 ? TYPES.STRAIGHT : TYPES.CURVE;
                    grid[r][c].type = group[Math.floor(Math.random() * group.length)];
                }
            }
        }

        train = { 
            x: 0, y: 0, dir: 1, 
            progress: 0.0, 
            speed: 0.005 + (level * 0.001) 
        };

        updateUI(); // åˆæœŸã®ãƒ¬ãƒ™ãƒ«è¡¨ç¤ºãªã©
        resize(); 
        gameLoop();
    }

    function getDir(from, to) {
        if(to.y < from.y) return 0; 
        if(to.x > from.x) return 1; 
        if(to.y > from.y) return 2; 
        if(to.x < from.x) return 3; 
        return -1;
    }

    function findTileByConnect(req) {
        const all = [...TYPES.STRAIGHT, ...TYPES.CURVE];
        return all.find(t => t.c[0] == req[0] && t.c[1] == req[1] && t.c[2] == req[2] && t.c[3] == req[3]);
    }

    canvas.addEventListener('pointerdown', (e) => {
        e.preventDefault(); 
        if(!isPlaying) return;
        const rect = canvas.getBoundingClientRect();
        const clickX = e.clientX - rect.left - offsetX;
        const clickY = e.clientY - rect.top - offsetY;
        const c = Math.floor(clickX / tileSize);
        const r = Math.floor(clickY / tileSize);

        if(c >= 0 && c < COLS && r >= 0 && r < ROWS) {
            rotateTile(c, r);
        }
    });

    function rotateTile(c, r) {
        const cell = grid[r][c];
        if(cell.fixed) return; 
        if(train.x === c && train.y === r) return; 

        const currentType = cell.type;
        const sIdx = TYPES.STRAIGHT.indexOf(currentType);
        if(sIdx >= 0) {
            cell.type = TYPES.STRAIGHT[(sIdx + 1) % 2];
            draw(); return;
        }
        const cIdx = TYPES.CURVE.indexOf(currentType);
        if(cIdx >= 0) {
            cell.type = TYPES.CURVE[(cIdx + 1) % 4];
            draw(); return;
        }
    }

    function gameLoop() {
        if(!isPlaying) return;
        
        // â–¼â–¼â–¼ è¿½åŠ : ãƒ—ãƒ¬ã‚¤ä¸­ã«ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§æ™‚é–“ã‚’æ›´æ–° â–¼â–¼â–¼
        if(gameStartTime > 0) {
            let currentSec = ((Date.now() - gameStartTime) / 1000).toFixed(1);
            let timeDisp = document.getElementById('time-disp');
            if(timeDisp) timeDisp.textContent = currentSec;
        }

        if (countdownVal < 0) {
            updateTrain();
        }
        
        draw();
        requestAnimationFrame(gameLoop);
    }

    function updateTrain() {
        let currentSpeed = train.speed;
        if(isSpeedUp) currentSpeed *= 4;

        train.progress += currentSpeed;

        if(train.progress >= 1.0) {
            let nextX = train.x;
            let nextY = train.y;

            if(train.dir === 0) nextY--;
            if(train.dir === 1) nextX++;
            if(train.dir === 2) nextY++;
            if(train.dir === 3) nextX--;

            if(nextX < 0 || nextX >= COLS || nextY < 0 || nextY >= ROWS) {
                gameOver(); return;
            }

            const nextTile = grid[nextY][nextX].type;
            const enterDir = (train.dir + 2) % 4;

            if(nextTile.c[enterDir] === 1) {
                train.x = nextX;
                train.y = nextY;
                train.progress = 0;

                for(let i=0; i<4; i++) {
                    if(i !== enterDir && nextTile.c[i] === 1) {
                        train.dir = i; break;
                    }
                }
                if(train.x === COLS-1 && train.y === ROWS-1) gameClear();
            } else {
                gameOver();
            }
        }
    }

    function speedUp(on) { isSpeedUp = on; }
    function gameOver() { isPlaying = false; document.getElementById('gameover-screen').style.display = 'flex'; }
    function gameClear() { isPlaying = false; updateUI(); document.getElementById('clear-screen').style.display = 'flex'; }
    
    function updateUI() { 
        document.getElementById('level-disp').textContent = level; 
        // score-dispã®æ›´æ–°ã¯å‰Šé™¤ï¼ˆä»£ã‚ã‚Šã«gameLoopã§time-dispã‚’æ›´æ–°ï¼‰
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        for(let r=0; r<ROWS; r++) {
            for(let c=0; c<COLS; c++) drawTile(c, r, grid[r][c]);
        }
        drawTrain();

        if(countdownVal >= 0) {
            ctx.fillStyle = "rgba(0,0,0,0.5)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "white";
            ctx.strokeStyle = "#2e7d32";
            ctx.lineWidth = 5;
            ctx.font = "bold 100px sans-serif";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            const text = (countdownVal === 0) ? "GO!" : countdownVal;
            ctx.strokeText(text, canvas.width/2, canvas.height/2);
            ctx.fillText(text, canvas.width/2, canvas.height/2);
        }
    }

    function drawTile(c, r, cell) {
        const x = offsetX + c * tileSize;
        const y = offsetY + r * tileSize;
        const cx = x + tileSize/2;
        const cy = y + tileSize/2;
        const w = tileSize;

        ctx.fillStyle = (c+r)%2 === 0 ? '#dcedc8' : '#f1f8e9'; 
        if(c === 0 && r === 0) ctx.fillStyle = '#b3e5fc';
        if(c === COLS-1 && r === ROWS-1) ctx.fillStyle = '#ffcdd2'; 

        ctx.fillRect(x, y, w, w);
        ctx.strokeStyle = '#aed581';
        ctx.strokeRect(x, y, w, w);

        if(c === 0 && r === 0) drawText(cx, cy, "ğŸ ");
        if(c === COLS-1 && r === ROWS-1) drawText(cx, cy, "ğŸ");

        if(cell.type) {
            ctx.lineWidth = tileSize * 0.3;
            ctx.lineCap = 'round';
            ctx.strokeStyle = '#795548'; 
            ctx.beginPath();
            const conn = cell.type.c; 
            if(conn[0] && conn[2]) { ctx.moveTo(cx, y); ctx.lineTo(cx, y+w); } 
            else if(conn[1] && conn[3]) { ctx.moveTo(x, cy); ctx.lineTo(x+w, cy); }
            else {
                if(conn[0] && conn[1]) { ctx.moveTo(cx, y); ctx.lineTo(cx, cy); ctx.lineTo(x+w, cy); }
                else if(conn[1] && conn[2]) { ctx.moveTo(x+w, cy); ctx.lineTo(cx, cy); ctx.lineTo(cx, y+w); }
                else if(conn[2] && conn[3]) { ctx.moveTo(cx, y+w); ctx.lineTo(cx, cy); ctx.lineTo(x, cy); }
                else if(conn[3] && conn[0]) { ctx.moveTo(x, cy); ctx.lineTo(cx, cy); ctx.lineTo(cx, y); }
            }
            ctx.stroke();
            ctx.lineWidth = tileSize * 0.2;
            ctx.strokeStyle = '#d7ccc8';
            ctx.stroke();
            if(cell.fixed) {
                ctx.fillStyle = 'rgba(0,0,0,0.2)';
                ctx.beginPath();
                ctx.arc(cx, cy, 6, 0, Math.PI*2);
                ctx.fill();
            }
        }
    }

    function drawText(x, y, text) {
        ctx.font = `${tileSize * 0.4}px serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, x, y);
    }

    function drawTrain() {
        const tx = offsetX + train.x * tileSize;
        const ty = offsetY + train.y * tileSize;
        const half = tileSize/2;
        const p = train.progress;
        let px = tx + half;
        let py = ty + half;
        
        const enterDir = (train.dir + 2) % 4;
        let startX=px, startY=py, endX=px, endY=py;
        if(enterDir === 0) startY -= half; 
        if(enterDir === 1) startX += half; 
        if(enterDir === 2) startY += half; 
        if(enterDir === 3) startX -= half; 
        if(train.dir === 0) endY -= half;
        if(train.dir === 1) endX += half;
        if(train.dir === 2) endY += half;
        if(train.dir === 3) endX -= half;

        let drawX, drawY;
        if(p < 0.5) {
            const pp = p * 2;
            drawX = startX + (px - startX) * pp;
            drawY = startY + (py - startY) * pp;
        } else {
            const pp = (p - 0.5) * 2;
            drawX = px + (endX - px) * pp;
            drawY = py + (endY - py) * pp;
        }

        ctx.save();
        ctx.translate(drawX, drawY);
        ctx.fillStyle = '#6d4c41';
        const cartSize = tileSize * 0.7;
        ctx.fillRect(-cartSize/2, -cartSize/2, cartSize, cartSize);
        ctx.fillStyle = '#3e2723';
        const wheelSize = cartSize * 0.3;
        ctx.fillRect(-cartSize/2 - 2, -cartSize/2, wheelSize, wheelSize);
        ctx.fillRect(cartSize/2 - wheelSize + 2, -cartSize/2, wheelSize, wheelSize);
        ctx.fillRect(-cartSize/2 - 2, cartSize/2 - wheelSize, wheelSize, wheelSize);
        ctx.fillRect(cartSize/2 - wheelSize + 2, cartSize/2 - wheelSize, wheelSize, wheelSize);
        const imgSize = tileSize * 0.8;
        const imgY = -cartSize/2 - imgSize/2 + (tileSize * 0.1); 
        ctx.drawImage(playerImg, -imgSize/2, imgY, imgSize, imgSize);
        ctx.restore();
    }

    // â–¼â–¼â–¼ è¿½åŠ ï¼šãƒ©ãƒ³ã‚­ãƒ³ã‚°ä¿å­˜æ©Ÿèƒ½ â–¼â–¼â–¼
    function saveScoreToRanking() {
        // ranking.js ã® showSaveDialog ã‚’å‘¼ã³å‡ºã—ã¾ã™
        // ã“ã‚Œã‚’å‘¼ã¶ã ã‘ã§ã€Œåå‰å…¥åŠ›ã€â†’ã€Œå…¨å›½ãƒ©ãƒ³ã‚­ãƒ³ã‚°ç™»éŒ²(ä»»æ„)ã€ã®æµã‚ŒãŒè‡ªå‹•ã§å‹•ãã¾ã™
        if (typeof showSaveDialog === 'function') {
            // ç¬¬1å¼•æ•°: æ‰‹é †1ã§ç™»éŒ²ã—ãŸID 'rail'
            // ç¬¬2å¼•æ•°: ä»Šå›ã®ã‚¿ã‚¤ãƒ  (finalTime)
            showSaveDialog('rail', finalTime);
        } else {
            alert('ranking.js ãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“');
        }
    }

</script>
</body>
</html>